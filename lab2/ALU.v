
`include "ALU_1bit.v"

module ALU(
    input [31:0] aluSrc1,   // [31:0] 代表 0 到 31 位元
    input [31:0] aluSrc2,
    input invertA,
    input invertB,
    input [1:0] operation,

    output reg [31:0] result,
    output reg zero,
    output reg overflow,  // Overflow = CarryIn[31] xor CarryOut[31]
    output reg set  // it's generated by ALU31 and send to ALU0 裡的 less signal
);

    

    wire [31:0] carry_out;  // 用於儲存每一位 ALU_1bit 的CarryOut
    wire [31:0] ALU_result;

    genvar i;   // generate variable
    generate  // 在實現多位元操作的時候, generate 區塊用於重複生成硬件結構
        for(i = 0; i < 32; i = i+1) begin: gen_ALU_bits
            ALU_1bit ALU1bit(
                .a(aluSrc1[i]),
                .b(aluSrc2[i]),
                .Ainvert(invertA),
                .Binvert(invertB),
                .operation(operation),
                // if i == 0 (ALU的最低位) -> 查看是否invertB是1, 且為減法 or less操作 
                // if是 -> carryIn = 1, else -> carryIn = 0. else if i 不為 0, carryIn = 上一位的carryOut
                .CarryIn(i == 0 ? (invertB && ((operation == 2'b11) || (operation == 2'b01)) ? 1'b1 : 1'b0) : carry_out[i-1]), 
                .Less(i == 31 ? set: 1'b0),   // if i == 31 (ALU31) -> less = set, if i不為31, less = 0 (不影響結果)
                .Result(ALU_result[i]),
                .CarryOut(carry_out[i])
            );
        end
    endgenerate

    always @(*) begin
        result = ALU_result;
        zero = (result == 0);    // if result == 0 -> zero = 1, else zero = 0
        overflow = carry_out[30] ^ carry_out[31];
        // 生成set信號: 如果進行減法操作且結果為負，則設置set為1
        if (operation == 2'b11 && invertB) begin
            set = ALU_result[31]; // 根據結果的最高位設定set
        end 
        else begin
            set = 0;
        end
    end
endmodule
